#!/usr/bin/env lua
--
-- Zmacs command generator.
--
-- Copyright (c) 2013-2014 Free Software Foundation, Inc.
--
-- This file is part of GNU Zile.
--
-- This program is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3, or (at your option)
-- any later version.
--
-- This program is distributed in the hope that it will be useful, but
-- WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

local getopt = require "std.getopt"
local io     = require "std.io_ext"

local zz   = require "zile.zlisp"
local prog = require "zile.version"



--[[ ======================== ]]--
--[[ Symbol Table Management. ]]--
--[[ ======================== ]]--


--- Make a new symbol and intern to `symtab`.
-- Overwrites any previous definition of symbol `name` in `symtab`.
-- @string name symbol name
-- @param[opt=nil] value value to store in new symbol
-- @tparam[opt=obarray] table symtab symbol table into which new symbol is
--   interned
-- @treturn zile.Symbol newly initialised symbol.
local function define (name, value, symtab)
  local symbol = zz.intern (name, symtab)
  symbol.value = value
  return symbol
end



--[[ ======================= ]]--
--[[ ZLisp Command Handlers. ]]--
--[[ ======================= ]]--


local function writef (...) io.write (string.format (...)) end


-- (defvar NAME INITVALUE [DOCSTRING])
-- A special form for describing Zmacs variables.  Each time it is called
-- by Zlisp, output a lua variable declaration for loading into Zmacs.
define ("defvar",
  function (arglist)
    local initvalue = arglist:nth (2)

    if type (initvalue) == "string" then
      initvalue = '"' .. initvalue .. '"'
    elseif type (initvalue) == "table" and initvalue.name == "t" then
      initvalue = "true"
    end

    writef ('\n\ndefvar ("%s", %s,\n[[\n%s\n]])\n',
            arglist:nth (1).name, tostring (initvalue),
	    arglist:nth (3) or "")
  end
)


-- (make-variable-buffer-local NAME)
-- Declare that NAME will maintain separate values for each buffer in
-- which it is set.
define ("make-variable-buffer-local",
  function (arglist)
    writef ('lisp.set_variable_buffer_local ("%s", true)\n', arglist:nth (1).name)
  end
)


-- Return true if SYMBOL is a valid parameter name.
local function isname (symbol)
  return symbol.name == "..." or symbol.name:match "^[%w_]" ~= nil
end


-- (defsubr NAME (PARAM...) DOCSTRING [(interactive)] (lambda "IMPLEMENTATION"))
-- A special form for describing Zmacs commands.  Each time it is called
-- by Zlisp, output a lua command declaration for binding into Zmacs.
define ("defsubr",
  function (arglist)
    local name        = arglist:nth (1).name
    local typelist    = arglist:nth (2)
    local docstring   = arglist:nth (3)
    local interactive = arglist:nth (4)

    local impl
    if interactive.car and interactive.car.name == "interactive" then
      impl = arglist:nth (5)
      interactive = true
    else
      impl = interactive
      interactive = false
    end

    if typelist and typelist.car then
      typelist = '"' .. typelist:concat ('", "') .. '"'
    else
      typelist = ""
    end

    local signature
    if type (impl) ~= "string" then
      local arglist = impl.cdr.car and impl.cdr.car.value or nil
      if arglist then
        signature = name .. " " ..
	  arglist:mapconcat (function (symbol)
		               local name = symbol.name
		               return isname (symbol) and name:upper () or name
			     end, " ")
      end

      impl = zz.call_command (impl.car, impl.cdr)
    end

    -- Don't re-add a function signature if docstring has one already.
    if docstring:match "^%(" == nil then
      signature = signature or name
      docstring = "(" .. signature .. ")\n\n" .. docstring
    end

    writef ('\n\ndefsubr ("%s",\n  {%s},\n[[\n%s\n]],\n  %s,\n  %s\n)\n',
            name, typelist, docstring,
	    tostring (interactive), tostring (impl))
  end
)


define ("lambda",
  function (arglist)
    local params = arglist:nth (1)

    if params and params.car then
      params = params:filter (isname)
    end

    if params and params.car then
      params = params:mapconcat (function (symbol)
                                   return symbol.name:gsub ("[^%w%d%.]", "_")
                                 end, ", ")
    else
      params = ""
    end

    return string.format ("function (%s)\n    %s\n  end",
      params, arglist:nth (2))
  end
)


-- (localfun NAME (PARAM...) [DOCSTRING] "IMPLEMENTATION")
define ("localfun",
  function (arglist)
    local params = arglist:nth (2)
    local impl = arglist:nth (3)

    if params and params.car then
      params = params:mapconcat (
                 function (symbol) return symbol.name end, ", ")
    else
      params = ""
    end

    io.write ("\n\n")
    if arglist:nth (4) ~= nil then
      io.write ("-- " .. impl:gsub ("\n", "\n-- ") .. "\n")
      impl = arglist:nth (4)
    end

    writef ("local function %s (%s)\n  %s\nend\n",
            arglist:nth (1).name, params, impl)
  end
)


-- (localvar NAME [DOCSTRING] "INITIAL-VALUE")
define ("localvar",
  function (arglist)
    local init = arglist:nth (2)

    io.write ("\n\n")
    if arglist:nth (3) ~= nil then
      io.write ("-- " .. init:gsub ("\n", "\n-- ") .. "\n")
      init = arglist:nth (3)
    end

    writef ("local %s = %s\n", arglist:nth (1).name, tostring (init))
  end
)



--[[ =============== ]]--
--[[ Option Parsing. ]]--
--[[ =============== ]]--

prog.banner = prog.version .. "\n" ..
  "Written by Gary V. Vaughan <gary@gnu.org>, 2013\n" ..
  "\n" ..
  prog.COPYRIGHT_STRING .. "\n" ..
  prog.COPYRIGHT_NOTICE .. "\n"

getopt.processArgs (prog)

if #arg == 0 then
  getopt.usage ()
  os.exit (1)
end


-- Preamble.
io.writelines ('-- Generated by ' .. prog.name .. '.',
  '-- ' .. prog.COPYRIGHT_STRING,
  '',
  'local lisp = require "zmacs.eval"',
  'local defsubr, defvar = lisp.defsubr, lisp.defvar')


-- Treat remaining arguments as filenames to be evaluated by Zlisp.
for i = 1, #arg do
  local ok, errmsg = zz.eval_file (arg[i])
  if not ok then
    errmsg = errmsg or "unknown error"
    io.stderr:write (arg[i] .. ": " .. errmsg .. ".\n")
    os.exit (1)
  end
end
