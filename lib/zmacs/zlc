#!/usr/bin/env lua
--
-- Zmacs command generator.
--
-- Copyright (c) 2013-2014 Free Software Foundation, Inc.
--
-- This file is part of GNU Zile.
--
-- This program is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3, or (at your option)
-- any later version.
--
-- This program is distributed in the hope that it will be useful, but
-- WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

local getopt = require "std.getopt"
local io     = require "std.io_ext"

local zz   = require "zile.zlisp"
local prog = require "zile.version"


--[[ ======================= ]]--
--[[ ZLisp Command Handlers. ]]--
--[[ ======================= ]]--


local cur_file

local function writef (...) io.write (string.format (...)) end


-- (defvar NAME INITVALUE [DOCSTRING])
-- A special form for describing Zmacs variables.  Each time it is called
-- by Zlisp, output a lua variable declaration for loading into Zmacs.
zz.define ("defvar",
  function (arglist)
    local initvalue = arglist:nth (2)

    if type (initvalue) == "string" then
      initvalue = '"' .. initvalue .. '"'
    elseif type (initvalue) == "table" and initvalue.name == "t" then
      initvalue = "true"
    end

    writef ('\n\nDefvar ("%s", %s,\n  "%s",\n[[\n%s\n]])\n',
            arglist:nth (1).name, tostring (initvalue),
	    cur_file:gsub ("^.*/", ""), arglist:nth (3) or "")
  end
)


-- (make-variable-buffer-local NAME)
-- Declare that NAME will maintain separate values for each buffer in
-- which it is set.
zz.define ("make-variable-buffer-local",
  function (arglist)
    writef ('lisp.set_variable_buffer_local ("%s", true)\n', arglist:nth (1).name)
  end
)


-- Return true if VALUE is a valid parameter name.
local function isname (value)
  value = type (value) == "string" and value or tostring (value)
  return value == "..." or value:match "^[%w_]" ~= nil
end


-- (defun NAME (PARAM...) DOCSTRING [(interactive)] (lambda "IMPLEMENTATION"))
-- A special form for describing Zmacs commands.  Each time it is called
-- by Zlisp, output a lua command declaration for binding into Zmacs.
zz.define ("defun",
  function (arglist)
    local name        = arglist:nth (1).name
    local typelist    = arglist:nth (2)
    local docstring   = arglist:nth (3)
    local interactive = arglist:nth (4)

    local impl
    if interactive.car and interactive.car.name == "interactive" then
      impl = arglist:nth (5)
      interactive = true
    else
      impl = interactive
      interactive = false
    end

    if typelist and typelist.car then
      typelist = '"' .. typelist:concat ('", "') .. '"'
    else
      typelist = ""
    end

    local signature
    if type (impl) ~= "string" then
      local arglist = impl.cdr.car and impl.cdr.car.value or nil
      if arglist then
        signature = name .. " " ..
	  arglist:mapconcat (function (symbol)
		               local name = symbol.name
		               return isname (symbol) and name:upper () or name
			     end, " ")
      end

      impl = zz.call_command (impl.car, impl.cdr)
    end

    -- Don't re-add a function signature if docstring has one already.
    if docstring:match "^%(" == nil then
      signature = signature or name
      docstring = "(" .. signature .. ")\n\n" .. docstring
    end

    writef ('\n\nDefun ("%s",\n  {%s}, "%s",\n[[\n%s\n]],\n  %s,\n  %s\n)\n',
            name, typelist, cur_file:gsub ("^.*/", ""), docstring,
	    tostring (interactive), tostring (impl))
  end
)


zz.define ("lambda",
  function (arglist)
    local params = arglist:nth (1)

    if params and params.car then
      params = params:filter (isname)
    end

    if params and params.car then
      params = params:mapconcat (function (symbol)
                                   return symbol.name:gsub ("[^%w%d%.]", "_")
                                 end, ", ")
    else
      params = ""
    end

    return string.format ("function (%s)\n    %s\n  end",
      params, arglist:nth (2))
  end
)


-- (localfun NAME (PARAM...) [DOCSTRING] "IMPLEMENTATION")
zz.define ("localfun",
  function (arglist)
    local params = arglist:nth (2)
    local impl = arglist:nth (3)

    if params and params.car then
      params = params:concat (", ")
    else
      params = ""
    end

    io.write ("\n\n")
    if arglist:nth (4) ~= nil then
      io.write ("-- " .. impl:gsub ("\n", "\n-- ") .. "\n")
      impl = arglist:nth (4)
    end

    writef ("local function %s (%s)\n  %s\nend\n",
            arglist:nth (1).name, params, impl)
  end
)


-- (localvar NAME [DOCSTRING] "INITIAL-VALUE")
zz.define ("localvar",
  function (arglist)
    local init = arglist:nth (2)

    io.write ("\n\n")
    if arglist:nth (3) ~= nil then
      io.write ("-- " .. init:gsub ("\n", "\n-- ") .. "\n")
      init = arglist:nth (3)
    end

    writef ("local %s = %s\n", arglist:nth (1).name, tostring (init))
  end
)



--[[ =============== ]]--
--[[ Option Parsing. ]]--
--[[ =============== ]]--

prog.banner = prog.version .. "\n" ..
  "Written by Gary V. Vaughan <gary@gnu.org>, 2013\n" ..
  "\n" ..
  prog.COPYRIGHT_STRING .. "\n" ..
  prog.COPYRIGHT_NOTICE .. "\n"

getopt.processArgs (prog)

if #arg == 0 then
  getopt.usage ()
  os.exit (1)
end


-- Preamble.
io.writelines ('-- Generated by ' .. prog.name .. '.',
  '-- ' .. prog.COPYRIGHT_STRING,
  '',
  'local lisp = require "zmacs.eval"',
  'local Defun, Defvar = lisp.Defun, lisp.Defvar')


-- Treat remaining arguments as filenames to be evaluated by Zlisp.
for i = 1, #arg do
  cur_file = arg[i]
  local ok, errmsg = zz.eval_file (cur_file)
  if not ok then
    errmsg = errmsg or "unknown error"
    io.stderr:write (arg[i] .. ": " .. errmsg .. ".\n")
    os.exit (1)
  end
end
