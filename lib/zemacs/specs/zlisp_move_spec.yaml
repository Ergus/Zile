specify zlisp/move:
- describe beginning-of-line:

- describe end-of-line:

- describe backward-char:
  - context in batch mode:
    - before:
        zemacs = Zemacs {"--batch"}

    # Lisp context only - you can't send keystrokes in batch mode!
    - context with lisp:
      - it diagnoses invalid argument: |
          expect (zemacs:edit [[(backward-char "six")]]).
            to_contain_error 'backward-char: wrong-type-argument integerp "six"'
      - it moves point backwards one character:
          lisp = [[(end-of-line) (backward-char) (backward-delete-char)]]
          expect (zemacs:edit (lisp, "Fix a typ_o\n")).
            to_write_to_buffer "Fix a typo\n"
      - it accepts a character count argument:
          lisp = [[(end-of-line) (backward-char 6) (backward-delete-char)]]
          expect (zemacs:edit (lisp, "Fix _a typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it diagnoses backward move from start of buffer: |
          expect (zemacs:edit [[(backward-char)]]).
            to_contain_error "Beginning of buffer\n"
      - it move point forward with a negative character count:
          lisp = [[(backward-char -6) (delete-char)]]
          expect (zemacs:edit (lisp, "Fix a _typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it diagnoses forward move from end of buffer: |
          expect (zemacs:edit ([[(backward-char -3)]], "x")).
            to_contain_error "End of buffer\n"

  - context in interactive mode:
    - before:
        zemacs = Zemacs {"--no-init-file"}
    - context with lisp:
      - it diagnoses invalid argument: |
          expect (zemacs:edit [[(backward-char "six")]]).
            to_write_to_minibuf 'backward-char: wrong-type-argument integerp "six"'
      - it moves point backwards one character:
          lisp = [[(end-of-line) (backward-char) (backward-delete-char)]]
          expect (zemacs:edit (lisp, "Fix a typ_o\n")).
            to_write_to_buffer "Fix a typo\n"
      - it accepts a character count argument:
          lisp = [[(end-of-line) (backward-char 6) (backward-delete-char)]]
          expect (zemacs:edit (lisp, "Fix _a typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it diagnoses backward move from start of buffer: |
          expect (zemacs:edit [[(backward-char)]]).
            to_write_to_minibuf "Beginning of buffer"
      - it move point forward with a negative character count:
          lisp = [[(backward-char -6) (delete-char)]]
          expect (zemacs:edit (lisp, "Fix a _typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it diagnoses forward move from end of buffer: |
          expect (zemacs:edit ([[(backward-char -3)]], "x")).
            to_write_to_minibuf "End of buffer"
    - context with keystrokes:
      - it moves point backwards one character: |
          expect (zemacs:edit [[1\LEFT2\LEFT3]]).
            to_write_to_buffer "321"
      - it accepts a character count argument:
          keystrokes = [[\C-e\M-6\LEFT^]]
          expect (zemacs:edit (keystrokes, "buffer text\n")).
            to_write_to_buffer "buffe^r text\n"
      - it understands the universal argument:
          keystrokes = [[\C-e\C-u\LEFT^]]
          expect (zemacs:edit (keystrokes, "buffer text\n")).
            to_write_to_buffer "buffer ^text\n"
      - it diagnoses backward move from start of buffer: |
          expect (zemacs:edit [[\LEFT]]).
            to_write_to_minibuf "call-interactively: Beginning of buffer"
      - it move point forward with a negative character count:
          lisp = [[\ESC-6\LEFT^]]
          expect (zemacs:edit (lisp, "buffer text\n")).
            to_write_to_buffer "buffer^ text\n"
      - it diagnoses forward move from end of buffer: |
          expect (zemacs:edit ([[\M--\C-u\LEFT]], "x")).
            to_write_to_minibuf "call-interactively: End of buffer"

- describe forward-char:
  - context in batch mode:
    - before:
        zemacs = Zemacs {"--batch"}

    - context with lisp:
      - it diagnoses invalid argument: |
          expect (zemacs:edit [[(forward-char "six")]]).
            to_contain_error 'forward-char: wrong-type-argument integerp "six"'
      - it moves point forwards one character:
          lisp = [[(forward-char) (delete-char)]]
          expect (zemacs:edit (lisp, "F_ix a typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it accepts a character count argument:
          lisp = [[(forward-char 6) (delete-char)]]
          expect (zemacs:edit (lisp, "Fix a _typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it diagnoses forward move from end of buffer: |
          expect (zemacs:edit [[(end-of-buffer) (forward-char)]]).
            to_contain_error "End of buffer\n"
      - it moves point backward with a negative character count:
          lisp = [[(end-of-buffer) (forward-char -6) (delete-char)]]
          expect (zemacs:edit (lisp, "Fix a _typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it diagnoses backward move from beginning of buffer: |
          expect (zemacs:edit ([[(forward-char -3)]], "x")).
            to_contain_error "Beginning of buffer\n"

  - context in interactive mode:
    - before:
        zemacs = Zemacs {"--no-init-file"}
    - context with lisp:
      - it diagnoses invalid argument: |
          expect (zemacs:edit [[(forward-char "six")]]).
            to_write_to_minibuf 'forward-char: wrong-type-argument integerp "six"'
      - it moves point forwards one character:
          lisp = [[(forward-char) (delete-char)]]
          expect (zemacs:edit (lisp, "F_ix a typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it accepts a character count argument:
          lisp = [[(forward-char 6) (delete-char)]]
          expect (zemacs:edit (lisp, "Fix a _typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it diagnoses forward move from end of buffer: |
          expect (zemacs:edit [[(end-of-buffer) (forward-char)]]).
            to_write_to_minibuf "End of buffer"
      - it moves point backward with a negative character count:
          lisp = [[(end-of-buffer) (forward-char -6) (delete-char)]]
          expect (zemacs:edit (lisp, "Fix a _typo\n")).
            to_write_to_buffer "Fix a typo\n"
      - it diagnoses backward move from beginning of buffer: |
          expect (zemacs:edit ([[(forward-char -3)]], "x")).
            to_write_to_minibuf "Beginning of buffer"
    - context with keystrokes:
      - it moves point forwards one character: |
          expect (zemacs:edit ([[1\RIGHT2\RIGHT3]], "abc")).
            to_write_to_buffer "1a2b3c"
      - it accepts a character count argument:
          keystrokes = [[\M-6\RIGHT^]]
          expect (zemacs:edit (keystrokes, "buffer text\n")).
            to_write_to_buffer "buffer^ text\n"
      - it understands the universal argument:
          keystrokes = [[\C-u\RIGHT^]]
          expect (zemacs:edit (keystrokes, "buffer text\n")).
            to_write_to_buffer "buff^er text\n"
      - it diagnoses forward move from end of buffer: |
          expect (zemacs:edit [[\M->\C-f]]).
            to_write_to_minibuf "call-interactively: End of buffer"
      - it moves point backward with a negative character count:
          lisp = [[\C-e\M--6\RIGHT^]]
          expect (zemacs:edit (lisp, "buffer text\n")).
            to_write_to_buffer "buffe^r text\n"
      - it diagnoses backward move from beginning of buffer: |
          expect (zemacs:edit ([[\M--\C-u\RIGHT]], "x")).
            to_write_to_minibuf "call-interactively: Beginning of buffer"

- describe goto-char:
  - context in batch mode:
    - before:
        zemacs = Zemacs {"--batch"}

    - context with lisp:
      - it diagnoses invalid argument: |
          expect (zemacs:edit [[(goto-char "six")]]).
            to_contain_error 'goto-char: wrong-type-argument integerp "six"\n'
      - it accepts a character offset argument:
          lisp = [[(goto-char 10) (delete-char)]]
          expect (zemacs:edit (lisp, "Fix a typ_o\n")).
            to_write_to_buffer "Fix a typo\n"
      - it rounds too small offset to start of buffer: |
          lisp = [[(goto-char -1) (delete-char)]]
          expect (zemacs:edit (lisp, "_rest of buffer\n")).
            to_write_to_buffer "rest of buffer\n"
      - it rounds too large offset to end of buffer: |
          lisp = [[(goto-char 999999) (backward-delete-char)]]
          expect (zemacs:edit (lisp, "rest of buffer\n_")).
            to_write_to_buffer "rest of buffer\n"

  - context in interactive mode:
    - before:
        zemacs = Zemacs {"--no-init-file"}
    - context with lisp:
      - it diagnoses invalid argument: |
          expect (zemacs:edit [[(goto-char "six")]]).
            to_write_to_minibuf 'goto-char: wrong-type-argument integerp "six"'
      - it accepts a character count argument:
          lisp = [[(goto-char 10) (delete-char)]]
          expect (zemacs:edit (lisp, "Fix a typ_o\n")).
            to_write_to_buffer "Fix a typo\n"
      - it rounds too small offset to start of buffer: |
          lisp = [[(goto-char -1) (delete-char)]]
          expect (zemacs:edit (lisp, "_rest of buffer\n")).
            to_write_to_buffer "rest of buffer\n"
      - it rounds too large offset to end of buffer: |
          lisp = [[(goto-char 999999) (backward-delete-char)]]
          expect (zemacs:edit (lisp, "rest of buffer\n_")).
            to_write_to_buffer "rest of buffer\n"
    - context with keystrokes:
      - it moves point to provided offset: |
          expect (zemacs:edit [[1\M-gc1\r2\M-gc2\r3]]).
            to_write_to_buffer "231"
      - it accepts a character count argument:
          keystrokes = [[\M-6\M-gc^]]
          expect (zemacs:edit (keystrokes, "buffer text\n")).
            to_write_to_buffer "buffe^r text\n"
      - it understands the universal argument:
          keystrokes = [[\C-u\M-gc^]]
          expect (zemacs:edit (keystrokes, "buffer text\n")).
            to_write_to_buffer "buf^fer text\n"
      - it rounds too small offset to start of buffer: |
          keystrokes = [[\M--1\M-gc^]]
          expect (zemacs:edit (keystrokes, "buffer text\n")).
            to_write_to_buffer "^buffer text\n"
      - it rounds too large offset to end of buffer: |
          keystrokes = [[\C-u10000\M-gc^]]
          expect (zemacs:edit (keystrokes, "buffer text")).
            to_write_to_buffer "buffer text^"

- describe goto-line:

- describe previous-line:

- describe next-line:

- describe beginning-of-buffer:

- describe end-of-buffer:

- describe scroll-down:

- describe scroll-up:

# No keystrokes, because forward-char is not bound to a key.
- describe forward-line:
  - before:
      content = "a buffer\nstring with\nseveral lines of\ntext"
  - context in batch mode:
    - before:
        zemacs = Zemacs {"--batch"}

    - context with lisp:
      - it diagnoses invalid argument: |
          expect (zemacs:edit [[(forward-line "six")]]).
            to_contain_error 'forward-line: wrong-type-argument integerp "six"'
      - it moves point forwards one line:
          expect (zemacs:edit ([[(forward-line) (insert "^")]], content)).
            to_write_to_buffer "^string with\n"
      - it moves to the end of a non-empty line at the end:
          expect (zemacs:edit ([[(forward-line) (insert "^")]], "non-empty line")).
            to_write_to_buffer "non-empty line^"
      - it returns 0 for a successful line movement: |
          expect (zemacs:edit ([[(message "remain=%d" (forward-line))]], content)).
            to_contain_error "remain=0\n"
      - it accepts a line count argument:
          expect (zemacs:edit ([[(forward-line 2) (insert "^")]], content)).
            to_write_to_buffer "^several lines of\n"
      - it moves to the beginning-of-line with zero argument:
          lisp = [[(end-of-buffer) (forward-line 0) (insert "^")]]
          expect (zemacs:edit (lisp, content)).to_match_buffer "\n%^text$"
      - it returns remainder for a partial line movement: |
          expect (zemacs:edit ([[(message "remain=%d" (forward-line 6))]], content)).
            to_contain_error "remain=2\n"
      - it moves point backward with a negative line count:
          lisp = [[(end-of-buffer) (forward-line -1) (insert "^")]]
          expect (zemacs:edit (lisp, content)).
            to_write_to_buffer "^several lines of\n"
          lisp = [[(end-of-buffer) (forward-line -2) (insert "^")]]
          expect (zemacs:edit (lisp, content)).
            to_write_to_buffer "^string with\n"
      - it returns remainder for a partial backwards line movement: |
          expect (zemacs:edit ([[(message "remain=%d" (forward-line -6))]], content)).
            to_contain_error "remain=6\n"

  - context in interactive mode:
    - before:
        zemacs = Zemacs {"--no-init-file"}
    - context with lisp:
      - it diagnoses invalid argument: |
          expect (zemacs:edit [[(forward-line "six")]]).
            to_write_to_minibuf 'forward-line: wrong-type-argument integerp "six"'
      - it moves point forwards one line:
          expect (zemacs:edit ([[(forward-line) (insert "^")]], content)).
            to_write_to_buffer "^string with\n"
      - it moves to the end of a non-empty line at the end:
          expect (zemacs:edit ([[(forward-line) (insert "^")]], "non-empty line")).
            to_write_to_buffer "non-empty line^"
      - it returns 0 for a successful line movement: |
          expect (zemacs:edit ([[(message "remain=%d" (forward-line))]], content)).
            to_write_to_minibuf "remain=0\n"
      - it accepts a line count argument:
          expect (zemacs:edit ([[(forward-line 2) (insert "^")]], content)).
            to_write_to_buffer "^several lines of\n"
      - it moves to the beginning-of-line with zero argument:
          lisp = [[(end-of-buffer) (forward-line 0) (insert "^")]]
          expect (zemacs:edit (lisp, content)).to_match_buffer "\n%^text$"
      - it returns remainder for a partial line movement: |
          expect (zemacs:edit ([[(message "remain=%d" (forward-line 6))]], content)).
            to_write_to_minibuf "remain=2\n"
      - it moves point backward with a negative line count:
          lisp = [[(end-of-buffer) (forward-line -1) (insert "^")]]
          expect (zemacs:edit (lisp, content)).
            to_write_to_buffer "^several lines of\n"
          lisp = [[(end-of-buffer) (forward-line -2) (insert "^")]]
          expect (zemacs:edit (lisp, content)).
            to_write_to_buffer "^string with\n"
      - it returns remainder for a partial backwards line movement: |
          expect (zemacs:edit ([[(message "remain=%d" (forward-line -6))]], content)).
            to_write_to_minibuf "remain=6\n"

- describe backward-paragraph:

- describe forward-paragraph:

- describe backward-sexp:

- describe forward-sexp:

- describe back-to-indentation:

- describe backward-word:

- describe forward-word:
