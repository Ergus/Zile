before:
  Object = require "std.object"
  Array  = require "zile.Array"

  prototype = Object.prototype

specify Array:
- before:
    array = Array ("long", 1, 1)
    -- append until it overflows
    repeat
      array:push (array[-1] + array[-2])
    until array[-1] < array[-2]
    array:pop ()

- describe _init:
  - it diagnoses missing argument:
      expect (Array ()).to_error "string expected, got no value"
  - it diagnoses wrong argument type:
      expect (Array "function").to_error "type function does not exist"
      expect (Array ("int", function () end)).to_error "number expected, got function"
  - it constructs an empty array:
      array = Array "int"
      expect (#array).to_be (0)
  - it constructs an initialised array: |
      for i = 3, #array do
        expect (array[i]).to_be (array[i - 1] + array[i -2])
      end

- describe __len:
  - it returns the number of elements stored:
      array = Array "char"
      expect (#array).to_be (0)
      array = Array ("short", 1, 2, 3)
      expect (#array).to_be (3)

- describe __index:
  - it returns nil for an empty array:
      array = Array "int"
      expect (array[1]).to_be (nil)
      expect (array[-1]).to_be (nil)
  - it retrieves a value stored at that index:
      expect (array[1]).to_be (1)
      expect (array[2]).to_be (1)
      expect (array[3]).to_be (2)
      expect (array[4]).to_be (3)
      expect (array[5]).to_be (5)
  - it retrieves negative indices counting from the right: |
      expect (array[-1]).to_be (array[#array])
      expect (array[-2]).to_be (array[#array - 1])
      expect (array[-(#array - 1)]).to_be (array[2])
      expect (array[-(#array)]).to_be (array[1])
  - it returns nil for out of bounds indices:
      expect (array[-(#array * 2)]).to_be (nil)
      expect (array[-(#array + 1)]).to_be (nil)
      expect (array[0]).to_be (nil)
      expect (array[#array + 1]).to_be (nil)
      expect (array[#array * 2]).to_be (nil)
  - it retrieves method names:
      expect (type (array.push)).to_be "function"
      expect (type (array.pop)).to_be "function"
  - it diagnoses undefined methods:
      expect (array.notamethod ()).to_error "attempt to call field 'notamethod'"

- describe __newindex:
  - it sets a new value at that index:
      array[2] = 2
      expect (array[2]).to_be (2)
  - it sets negative indexed elements counting from the right: |
      for i = 1, #array do array[-i] = #array - i + 1 end
      for i = 1, #array do
        expect (array[i]).to_be (i)
      end
  - it diagnoses out of bounds indices: |
      for _, i in ipairs {#array * -2, -1 - #array, 0, #array + 1, #array * 2} do
        expect ((function () array[i] = i end) ()).
          to_error "array access out of bounds"
      end

- describe __tostring:
  - it renders all elements of the array:
      array = Array ("char", 1, 4, 9, 16, 25)
      expect (tostring (array)).to_be 'Array ("char", 1, 4, 9, 16, 25)'

- describe pop:
  - context when called as a module function:
    - before:
        -- Rounding impedance mismatch between Lua double and alien long, so we
        -- use an intentionally short array for this example.
        array = Array ("short", 1, 1, 2 ,3, 5, 8, 13, 21, 34, 55, 89)
    - it returns nil for an empty array:
        array = Array "char"
        expect (Array.pop (array)).to_be (nil)
    - it removes an element from the array: |
        count = #array
        repeat
          expect (#array).to_be (count)
          count = count - 1
        until Array.pop (array) == nil
        expect (#array).to_be (0)
    - it returns the removed element: |
        while #array > 2 do
          expect (Array.pop (array)).to_be (array[-1] + array[-2])
        end
    - it does not perturb existing elements: |
        Array.pop (array)
        for i = 3, #array do
          expect (array[i]).to_be (array[i -1] + array[i - 2])
        end
  - context when called as an object method:
    - before:
        -- Rounding impedance mismatch between Lua double and alien long, so we
        -- use an intentionally short array for this example.
        array = Array ("short", 1, 1, 2 ,3, 5, 8, 13, 21, 34, 55, 89)
    - it returns nil for an empty array:
        array = Array "char"
        expect (array:pop ()).to_be (nil)
    - it removes an element from the array: |
        count = #array
        repeat
          expect (#array).to_be (count)
          count = count - 1
        until array:pop () == nil
        expect (#array).to_be (0)
    - it returns the removed element: |
        while #array > 2 do
          expect (array:pop ()).to_be (array[-1] + array[-2])
        end
    - it does not perturb existing elements: |
        array:pop ()
        for i = 3, #array do
          expect (array[i]).to_be (array[i -1] + array[i - 2])
        end

- describe push:
  - context when called as a module function:
    - before:
        -- Rounding impedance mismatch between Lua double and alien long, so we
        -- use an intentionally short array for this example.
        array = Array ("short", 1, 1, 2 ,3, 5, 8, 13, 21, 34, 55, 89)
    - it diagnoses missing argument:
        expect (Array.push (array)).to_error "number expected, got no value"
    - it diagnoses wrong argument type:
        expect (Array.push (array, function () end)).to_error "number expected, got function"
    - it adds a single element to an empty array:
        array = Array "int"
        Array.push (array, 42)
        expect (array[1]).to_be (array[-1])
    - it adds an element to an array: |
        count = #array
        Array.push (array, 42)
        expect (array[-1]).to_be (42)
        expect (#array).to_be (count + 1)
        Array.push (array, -273)
        expect (array[-1]).to_be (-273)
        expect (#array).to_be (count + 2)
    - it does not perturb existing elements: |
        Array.push (array, 42)
        for i = 3, #array - 1 do
          expect (array[i]).to_be (array[i - 1] + array[i - 2])
        end
  - context when called as an object method:
    - before:
        -- Rounding impedance mismatch between Lua double and alien long, so we
        -- use an intentionally short array for this example.
        array = Array ("short", 1, 1, 2 ,3, 5, 8, 13, 21, 34, 55, 89)
    - it diagnoses missing argument:
        expect (array:push ()).to_error "number expected, got no value"
    - it diagnoses wrong argument type:
        expect (array:push (function () end)).to_error "number expected, got function"
    - it adds a single element to an empty array:
        array = Array "int"
        array:push (42)
        expect (array[1]).to_be (array[-1])
    - it adds an element to an array: |
        count = #array
        array:push (42)
        expect (array[-1]).to_be (42)
        expect (#array).to_be (count + 1)
        array:push (-273)
        expect (array[-1]).to_be (-273)
        expect (#array).to_be (count + 2)
    - it returns itself: |
        count = #array
        array:push (42):push (-273)
        expect (array[-1]).to_be (-273)
        expect (array[-2]).to_be (42)
        expect (#array).to_be (count + 2)
    - it does not perturb existing elements: |
        array:push (42)
        for i = 3, #array - 1 do
          expect (array[i]).to_be (array[i - 1] + array[i -2])
        end
